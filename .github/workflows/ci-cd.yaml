name: CI/CD Pipeline

on:
  push:
    branches: [ main, master, cleanup, feature/*, bugfix/* ]
  pull_request:
    branches: [ main, master, cleanup, feature/*, bugfix/* ]

permissions:
  contents: read
  packages: write
  id-token: write

env:
  SERVER_A_IP: "37.32.15.192"
  SERVER_B_IP: "188.121.102.61"
  DEPLOY_AGENT_PORT: "8080"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: |
          cd api-service
          pip install -r requirements.txt

      - name: Run tests
        run: |
          cd api-service
          python -m pytest test_api.py -v

      - name: Test API endpoints
        run: |
          cd api-service
          echo "Checking if port 8000 is available..."
          if lsof -i :8000 >/dev/null 2>&1; then
            echo "Port 8000 is already in use, killing existing processes..."
            lsof -ti :8000 | xargs kill -9
            sleep 2
          fi
          
          echo "Starting API server..."
          python api-server.py > server.log 2>&1 &
          API_PID=$!
          
          echo "Server PID: $API_PID"
          echo "Waiting 5 seconds for server to start..."
          sleep 5
          
          echo "Checking if server process is running..."
          if ! ps -p $API_PID > /dev/null; then
            echo "‚ùå Server process died"
            echo "Server log:"
            cat server.log
            exit 1
          fi
          
          echo "Checking if port 8000 is listening..."
          if ! netstat -tlnp | grep :8000; then
            echo "‚ùå Port 8000 not listening"
            echo "Server log:"
            cat server.log
            exit 1
          fi
          
          echo "Testing /cons endpoint..."
          curl -f http://localhost:8000/cons
          
          echo "Stopping server..."
          kill $API_PID
          wait $API_PID 2>/dev/null || true

      - name: Test Docker build
        run: |
          cd api-service
          echo "Building Docker image..."
          docker build -t test-media-service .
          
          echo "Starting container..."
          docker run -d --name test-container -p 8001:8000 test-media-service
          
          echo "Waiting for container to be ready..."
          for i in {1..30}; do
            if curl -f http://localhost:8001/health >/dev/null 2>&1; then
              echo "Container is ready!"
              break
            fi
            echo "Attempt $i/30: Container not ready yet..."
            sleep 2
          done
          
          echo "Testing container health..."
          curl -f http://localhost:8001/health
          
          echo "Cleaning up..."
          docker stop test-container
          docker rm test-container

  build:
    runs-on: ubuntu-latest
    needs: test
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push Docker image
        run: |
          cd api-service
          docker build -t ghcr.io/${{ github.repository }}:${{ github.sha }} .
          docker tag ghcr.io/${{ github.repository }}:${{ github.sha }} ghcr.io/${{ github.repository }}:latest
          docker push ghcr.io/${{ github.repository }}:${{ github.sha }}
          docker push ghcr.io/${{ github.repository }}:latest

  deploy:
    runs-on: ubuntu-latest
    needs: build
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to Server A (First)
        run: |
          echo "üöÄ Rolling deployment: Deploying to Server A first..."
          curl -s -X POST "http://${{ env.SERVER_A_IP }}:${{ env.DEPLOY_AGENT_PORT }}/deploy" \
            -H "Authorization: Bearer ${{ secrets.DEPLOY_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"image_tag\": \"${{ github.sha }}\", \"registry_image\": \"ghcr.io/${{ github.repository }}\"}" \
            --max-time 60

      - name: Wait for Server A deployment
        run: |
          echo "‚è≥ Waiting for Server A deployment to stabilize..."
          sleep 30

      - name: Verify Server A deployment
        run: |
          echo "üîç Verifying Server A deployment..."
          curl -f "http://${{ env.SERVER_A_IP }}:8000/health" --max-time 30
          echo "‚úÖ Server A deployment verified successfully!"

      - name: Deploy to Server B (Second)
        run: |
          echo "üöÄ Rolling deployment: Deploying to Server B..."
          curl -s -X POST "http://${{ env.SERVER_B_IP }}:${{ env.DEPLOY_AGENT_PORT }}/deploy" \
            -H "Authorization: Bearer ${{ secrets.DEPLOY_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"image_tag\": \"${{ github.sha }}\", \"registry_image\": \"ghcr.io/${{ github.repository }}\"}" \
            --max-time 60

      - name: Wait for Server B deployment
        run: |
          echo "‚è≥ Waiting for Server B deployment to stabilize..."
          sleep 30

      - name: Verify Server B deployment
        run: |
          echo "üîç Verifying Server B deployment..."
          curl -f "http://${{ env.SERVER_B_IP }}:8000/health" --max-time 30
          echo "‚úÖ Server B deployment verified successfully!"

      - name: Final verification
        run: |
          echo "üéâ Rolling deployment completed successfully!"
          echo "Both servers are now running the new version."
